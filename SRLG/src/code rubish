


bool ILPAlgorithmBasicFlows_glpk(Graph *p_graph) {
	char s[1000];
	string strc;

	glp_prob *lp;
	lp = glp_create_prob();
	glp_set_prob_name(lp, "sample");
	glp_set_obj_dir(lp, GLP_MIN);
	int rownum = (2 * p_graph->nodeNum) + p_graph->edgeNum
			+ (3 * p_graph->srlgGroupsNum);
	int colnum = (2 * p_graph->edgeNum + 2 * p_graph->srlgGroupsNum);

	int index = 0;
	//AX1=u

	glp_add_cols(lp, colnum);
	//APedge
	strc = "APedge";
	for (int i = 1; i <= p_graph->edgeNum; i++) {
		sprintf(s, "%d", i);
		glp_set_col_name(lp, i + index, (strc + s).c_str());
		glp_set_col_kind(lp, i + index, GLP_IV);
		glp_set_col_bnds(lp, i, GLP_DB, 0.0, 1.0);
//		glp_set_col_stat(lp, i+ index,GLP_BS);
		glp_set_obj_coef(lp, i, p_graph->edges.at(i - 1).cost);

	}
	//BPedge
	index += p_graph->edgeNum;
	strc = "BPedge";
	for (int i = 1; i <= p_graph->edgeNum; i++) {
		sprintf(s, "%d", i);
		glp_set_col_name(lp, i + index, (strc + s).c_str());
		glp_set_col_kind(lp, i + index, GLP_IV);
		glp_set_col_bnds(lp, i + index, GLP_DB, 0.0, 1.0);
		glp_set_obj_coef(lp, i + index, 0.0);
//		glp_set_col_stat(lp, i+ index,GLP_BS);

	}

	//APsrlg
	index += p_graph->edgeNum;
	strc = "APsrlg";
	for (int i = 1; i <= p_graph->srlgGroupsNum; i++) {
		sprintf(s, "%d", i);
		glp_set_col_name(lp, i + index, (strc + s).c_str());
		glp_set_col_kind(lp, i + index, GLP_IV);
		glp_set_col_bnds(lp, i + index, GLP_DB, 0.0, 1.0);
		glp_set_obj_coef(lp, i + index, 0.0);
//		glp_set_col_stat(lp, i+ index,GLP_BS);

	}
	//BPsrlg
	index += p_graph->srlgGroupsNum;
	strc = "BPsrlg";
	for (int i = 1; i <= p_graph->srlgGroupsNum; i++) {
		sprintf(s, "%d", i);
		glp_set_col_name(lp, i + index, (strc + s).c_str());
		glp_set_col_kind(lp, i + index, GLP_IV);
		glp_set_col_bnds(lp, i + index, GLP_DB, 0.0, 1.0);
		glp_set_obj_coef(lp, i + index, 0.0);
//		glp_set_col_stat(lp, i+ index,GLP_NS);

	}



	index=0;
	glp_add_rows(lp, rownum);
	strc = "APinoutdegrezero";
	for (int i = 1; i <= p_graph->nodeNum; i++) {
		sprintf(s, "%d", i);

		glp_set_row_name(lp, i, (strc + s).c_str());
		if ((i - 1) == p_graph->source)
			glp_set_row_bnds(lp, i, GLP_FX, 1.0, 1.0);
		if ((i - 1) == p_graph->destination)
			glp_set_row_bnds(lp, i, GLP_FX, -1.0, -1.0);
		if (((i - 1) != p_graph->source) && ((i - 1) != p_graph->destination))
			glp_set_row_bnds(lp, i, GLP_FX, 0.0, 0.0);

	}

	//AX2=u
	index += p_graph->nodeNum;
	strc = "BPinoutdegrezero";
	for (int i = 1; i <= p_graph->nodeNum; i++) {
		sprintf(s, "%d", i);
		glp_set_row_name(lp, i + index, (strc + s).c_str());
		if ((i - 1) == p_graph->source)
			glp_set_row_bnds(lp, i + index, GLP_FX, 1.0, 1.0);
		if ((i - 1) == p_graph->destination)
			glp_set_row_bnds(lp, i + index, GLP_FX, -1.0, -1.0);
		if (((i - 1) != p_graph->source) && ((i - 1) != p_graph->destination))
			glp_set_row_bnds(lp, i + index, GLP_FX, 0.0, 0.0);
	}

	//0<=X1+X2<=1
	index += p_graph->nodeNum;
	strc = "APnotcrossBP";
	for (int i = 1; i <= p_graph->edgeNum; i++) {
		sprintf(s, "%d", i);
		glp_set_row_name(lp, i + index, (strc + s).c_str());
		glp_set_row_bnds(lp, i + index, GLP_DB, 0.0, 1.0);
	}

	//HX1-|E0|Z1<=0
	index += p_graph->edgeNum;
	strc = "APsrlg";
	for (int i = 1; i <= p_graph->srlgGroupsNum; i++) {
		sprintf(s, "%d", i);
		glp_set_row_name(lp, i + index, (strc + s).c_str());
		glp_set_row_bnds(lp, (i + index), GLP_DB, 0.0, 1.0);

	}
	//HX2-|E0|Z2<=0
	index += p_graph->srlgGroupsNum;
	strc = "BPsrlg";
	for (int i = 1; i <= p_graph->srlgGroupsNum; i++) {
		sprintf(s, "%d", i);
		glp_set_row_name(lp, i + index, (strc + s).c_str());
		glp_set_row_bnds(lp, (i + index), GLP_DB, 0.0, 1.0);

	}

	//0<=Z1+Z2<=1
	index += p_graph->srlgGroupsNum;
	strc = "APnotcrossBP";
	for (int i = 1; i <= p_graph->srlgGroupsNum; i++) {
		sprintf(s, "%d", i);
		glp_set_row_name(lp, i + index, (strc + s).c_str());
		glp_set_row_bnds(lp, (i + index), GLP_DB, 0.0, 1.0);
	}


	int *ia, *ja;
	double *ar;
	ia = (int*) malloc(((rownum * colnum) + 2) * sizeof(int));
	ja = (int*) malloc(((rownum * colnum) + 2) * sizeof(int));
	ar = (double*) malloc(((rownum * colnum) + 2) * sizeof(double));
	int jlimit1 = p_graph->edgeNum;
	int jlimit2 = 2 * p_graph->edgeNum;
	int jlimit3 = 2 * p_graph->edgeNum + p_graph->srlgGroupsNum;

	index = 1;
	int indexrow = 0;
	//AX1=u
	for (int i = 0; i < p_graph->nodeNum; i++) {
		for (int j = 0; j < colnum; j++) {
			ia[index] = i + 1;
			ja[index] = j + 1;
			ar[index] = 0;
			if (j < jlimit1) {
				if (i == p_graph->edges.at(j).from) {
					ar[index] = 1;
				}
				if (i == p_graph->edges.at(j).to) {
					ar[index] = -1;
				}
			}
			index++;
		}
	}
	//AX2=u
	indexrow += p_graph->nodeNum;
	for (int i = 0; i < p_graph->nodeNum; i++) {
		for (int j = 0; j < colnum; j++) {
			ia[index] = i + 1 + indexrow;
			ja[index] = j + 1;
			ar[index] = 0;
			if ((j < jlimit2) && (j >= jlimit1)) {
				if (i == p_graph->edges.at(j - jlimit1).from) {
					ar[index] = 1;
				}
				if (i == p_graph->edges.at(j - jlimit1).to) {
					ar[index] = -1;
				}
			}
			index++;
		}
	}
	//0<=X1+X2<=1
	indexrow += p_graph->nodeNum;
	for (int i = 0; i < p_graph->edgeNum; i++) {
		for (int j = 0; j < colnum; j++) {
			ia[index] = i + 1 + indexrow;
			ja[index] = j + 1;
			ar[index] = 0;
			if (j < jlimit1) {
				if (i == j) {
					ar[index] = 1;
				}
			}
			if ((j < jlimit2) && (j >= jlimit1)) {
				if (i == (j - jlimit1)) {
					ar[index] = 1;
				}
			}
			index++;
		}
	}

	//HX1-|E0|Z1<=0
	indexrow += p_graph->edgeNum;
	int E0 = p_graph->edgeNum;
	for (int i = 0; i < p_graph->srlgGroupsNum; i++) {
		for (int j = 0; j < colnum; j++) {
			ia[index] = i + 1 + indexrow;
			ja[index] = j + 1;
			ar[index] = 0;
			if (j < jlimit1) {
				if (i == p_graph->edges.at(j).ithsrlg) {
					ar[index] = -1;
				}
			}
			if ((j < jlimit3) && (j >= jlimit2)) {
				if (i == (j - jlimit2)) {
					ar[index] = 1.0
							* (p_graph->srlgGroups.at(i).srlgMember.size());
				}
			}
			index++;
		}
	}
	//HX2-|E0|Z2<=0
	indexrow += p_graph->srlgGroupsNum;
	for (int i = 0; i < p_graph->srlgGroupsNum; i++) {
		for (int j = 0; j < colnum; j++) {
			ia[index] = i + 1 + indexrow;
			ja[index] = j + 1;
			ar[index] = 0;
			if ((j >= jlimit1) && (j < jlimit2)) {
				if (i == p_graph->edges.at(j - jlimit1).ithsrlg)
					ar[index] = -1.0;

			}
			if ((j >= jlimit3)) {
				if (i == (j - jlimit3)) {
					ar[index] = 1.0
						* (p_graph->srlgGroups.at(i).srlgMember.size());
				}
			}
			index++;
		}
	}
	//0<=Z1+Z2<=1
	indexrow += p_graph->srlgGroupsNum;
	for (int i = 0; i < p_graph->srlgGroupsNum; i++) {
		for (int j = 0; j < colnum; j++) {
			ia[index] = i + 1 + indexrow;
			ja[index] = j + 1;
			ar[index] = 0;
			if ((j < jlimit3) && (j >= jlimit2)) {
				if ((j - jlimit2) == i) {
					ar[index] = 1;
				}
			}
			if ((j >= jlimit3)) {
				if ((j - jlimit3) == i) {
					ar[index] = 1;
				}
			}
			index++;

		}
	}

	glp_load_matrix(lp, (rownum * colnum), ia, ja, ar);
	glp_simplex(lp, NULL);
//	glp_interior(lp,NULL);

	if (!(GLP_OPT == glp_get_status(lp))) {
		return false;
	}
	cout << "ILP value:" << glp_get_obj_val(lp) << endl;
	cout << "glp get num rows" << glp_get_num_rows(lp) << endl;
	cout << "glp_get_num_cols" << glp_get_num_cols(lp) << endl;
	cout << " glp_get_num_nz" << glp_get_num_nz(lp) << endl;
	for (int i = 1; i <= colnum; i++) {
		if (glp_get_col_prim(lp, i)) {
			int id = i - 1;
			cout << glp_get_col_name(lp, i) << ":  " << glp_get_col_prim(lp, i);
//			cout << "  row_type :" << glp_get_col_type(lp, i);
			if (i <= jlimit2) {
				if (i > jlimit1)
					id -= jlimit1;
				cout << "   from "
						<< p_graph->node_index[p_graph->edges.at(id).from]
						<< "  to: "
						<< p_graph->node_index[p_graph->edges.at(id).to];
			}

			cout << endl;

		}
	}

	glp_delete_prob(lp);
	free(ia);
	free(ja);
	free(ar);
	return true;

}


bool findAP_dijastra(Graph *p_graph, Request *p_request) {
#ifndef	ConsolePrint
	cout << endl << "is finding the AP" << endl;
#endif
	typedef pair<int, int> P;
	vector<int> dist((*p_graph).nodeNum, (-1));
	vector<int> hop((*p_graph).nodeNum, (-1));
	vector<int> path_node((*p_graph).nodeNum, (-1));
	vector<int> path_edge((*p_graph).nodeNum, (-1));
	priority_queue<P, vector<P>, greater<P> > que;
	dist[(*p_graph).source] = 0;
	hop[(*p_graph).source] = 0;
	que.push(P(0, (*p_graph).source));

	while (!que.empty()) {
		P p = que.top();
		que.pop();
		int v = p.second;

		if (dist[v] < p.first)
			continue;
		for (unsigned int i = 0; i < (*p_graph).graphList[v].edgeList.size();
				i++) {

			Edge e = (*p_graph).edges.at((*p_graph).graphList[v].edgeList[i]);

			if (0 == (p_request->APMustNotPassEdges.size())) {
				cout << "p_request->APedgestabu is " << "NULL" << endl;
			}
			if (!p_request->APMustNotPassEdges[e.id])
				continue;
			if (-1 == dist[e.to]) {
				dist[e.to] = dist[v] + e.cost;
				hop[e.to] = hop[v] + 1;
				path_node[e.to] = v;
				path_edge[e.to] = e.id;
				que.push(P(dist[e.to], e.to));
			} else {
				if (dist[e.to] > dist[v] + e.cost) {
					dist[e.to] = dist[v] + e.cost;
					hop[e.to] = hop[v] + 1;
					path_node[e.to] = v;
					path_edge[e.to] = e.id;
					que.push(P(dist[e.to], e.to));
				}
			}
		}
	}

	for (int i = 0; i < p_graph->nodeNum; i++) {
		cout << p_graph->node_index[i] << " ---:" << dist[i] << endl;
	}

	if (-1 == dist[(*p_graph).destination]) {
		cout << "failed to find the AP" << endl;
		return false;
	} else {
		int now;
		int next;

		now = (*p_graph).destination;
		(*p_request).AP_PathNode.push_back(now);
		next = path_node[now];
		while (next != -1) {
			(*p_request).AP_PathNode.push_back(next);
			(*p_request).AP_PathEdge.push_back(path_edge[now]);
			//(*p_request).AP_CostSum += p_graph->edges[path_edge[now]].cost;

			(*p_request).BPMustNotPassEdges4AP[path_edge[now]] = false;
			if (-1 != p_graph->edges[path_edge[now]].ithsrlg)
				(*p_request).APSrlgs.push_back(
						p_graph->edges[path_edge[now]].ithsrlg);
			now = next;
			next = path_node[now];

		}

		(*p_request).APCostSum = dist[(*p_graph).destination];
		(*p_request).APHopSum = hop[(*p_graph).destination];
		for (unsigned int i = 0; i < (*p_request).APSrlgs.size(); i++) {
			int srlg = (*p_request).APSrlgs[i];
			for (unsigned int j = 0;
					j < (*p_graph).srlgGroups[srlg].srlgMember.size(); j++) {
				int srlgmem = (*p_graph).srlgGroups[srlg].srlgMember[j];
				if ((*p_request).BPMustNotPassEdges4AP[srlgmem]
						&& (*p_request).BPMustNotPassEdgesRLAP[srlgmem]) {
					(*p_request).BPMustNotPassEdgesRLAP[srlgmem] = false;
					p_request->RLAP_PathEdge.push_back(srlgmem);
				}
			}
		}

		cout << "succeed to find the AP cost:(" << (*p_request).APCostSum
				<< ") hop:(" << (*p_request).APHopSum << ") :";
		vector<int>::iterator it = (*p_request).AP_PathNode.end();
		do {
			it--;
			cout << p_graph->node_index[(*it)] << " ";
		} while (it != (*p_request).AP_PathNode.begin());
		cout << endl;

		cout << "edge list " << (*p_request).AP_PathEdge.size() << "  :";
		for (unsigned i = 0; i < (*p_request).AP_PathEdge.size(); i++) {
			cout << (*p_request).AP_PathEdge[i] << " ";
		}
		cout << endl;

		cout << "|AP|:" << p_request->AP_PathEdge.size() << "  |RLAP|:"
				<< p_request->RLAP_PathEdge.size() << endl;

		return true;
	}
}